export drop

function drop(M::CuSparseMatrixCSR, Mesh::MetaMesh, τ = 0.0001::AbstractFloat, stencil_max_depth::Int=3, r_tol::AbstractFloat = 700 * eps(real(eltype(M))),
        a_tol::AbstractFloat = 700 * eps(real(eltype(M)))) 
    
        rows,cols=size(M)

        e₁ = CUDA.zeros(eltype(M),rows)
        e₁[1:1] .= 1.0

        col, _ = gmres(M,e₁,atol=a_tol,rtol=r_tol) #Ax=e₁ (First column inverse)

        #Prune the inverse with the desired drop tolerance τ.
        bitindex = abs2.(col) .> τ

        #Get indexes of non pruned elements.
        int_index = findall(bitindex)|>Array

        #Stencil with desired depth
        stencil = get_linear_stencil(1,1,stencil_max_depth,Mesh)

        #Used stencil positions at stencil by droptolerance.
        stencil_positions = findall(in(int_index),stencil)

        #Here the entries not eliminated are chosen.
        used_stencil_idx = stencil[stencil_positions]

        nnz_stencil_positions = length(stencil_positions)

        #Checking a_ij==a_ji
        if 1:nnz_stencil_positions!=stencil_positions
            @warn "Problem with matrix entries (a_ij!=a_ji). Use a different drop tolerance..."
        end

        I = Array{Int64}(undef,rows*nnz_stencil_positions)

        J = Array{Int64}(undef,rows*nnz_stencil_positions)

        V = repeat(col[used_stencil_idx]|>Array,cols)

        #Access is independent. Construction can be done in parallel.
        @threads for idx in 1:length(Mesh)
            #Rows are generated by prunned stencil expansion at current position. 
            I[(nnz_stencil_positions * (idx - 1) + 1):(nnz_stencil_positions * idx)] .= get_linear_stencil(idx,
            1,
            stencil_max_depth,
            Mesh)[stencil_positions]
    
            #Column is always the same.
            J[(nnz_stencil_positions * (idx - 1) + 1):(nnz_stencil_positions * idx)] .= idx
        end
    return I,J,V
end
